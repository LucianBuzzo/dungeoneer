(function (f) { if (typeof exports === 'object' && typeof module !== 'undefined') { module.exports = f() } else if (typeof define === 'function' && define.amd) { define([], f) } else { let g; if (typeof window !== 'undefined') { g = window } else if (typeof global !== 'undefined') { g = global } else if (typeof self !== 'undefined') { g = self } else { g = this }g.Dungeoneer = f() } })(function () {
  let define, module, exports; return (function e (t, n, r) { function s (o, u) { if (!n[o]) { if (!t[o]) { const a = typeof require === 'function' && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); const f = new Error("Cannot find module '" + o + "'"); throw f.code = 'MODULE_NOT_FOUND', f } const l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { const n = t[o][1][e]; return s(n || e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require === 'function' && require; for (let o = 0; o < r.length; o++)s(r[o]); return s })({
    1: [function (require, module, exports) {
    /**
 * Based on Bob Nystrom's procedural dungeon generation logic that he wrote for Hauberk
 * http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/
 */

      'use strict'

      const Victor = require('victor')
      const _ = require('underscore')

      const Room = require('./room')
      const Tile = require('./tile')

      /**
 * @desc The random dungeon generator.
 *
 * Starting with a stage of solid walls, it works like so:
 *
 * 1. Place a number of randomly sized and positioned rooms. If a room
 *    overlaps an existing room, it is discarded. Any remaining rooms are
 *    carved out.
 * 2. Any remaining solid areas are filled in with mazes. The maze generator
 *    will grow and fill in even odd-shaped areas, but will not touch any
 *    rooms.
 * 3. The result of the previous two steps is a series of unconnected rooms
 *    and mazes. We walk the stage and find every tile that can be a
 *    "connector". This is a solid tile that is adjacent to two unconnected
 *    regions.
 * 4. We randomly choose connectors and open them or place a door there until
 *    all of the unconnected regions have been joined. There is also a slight
 *    chance to carve a connector between two already-joined regions, so that
 *    the dungeon isn't single connected.
 * 5. The mazes will have a lot of dead ends. Finally, we remove those by
 *    repeatedly filling in any open tile that's closed on three sides. When
 *    this is done, every corridor in a maze actually leads somewhere.
 *
 * The end result of this is a multiply-connected dungeon with rooms and lots
 * of winding corridors.
 *
 * @constructor
 */
      const Dungeon = function Dungeon () {
        const numRoomTries = 50

        // The inverse chance of adding a connector between two regions that have
        // already been joined. Increasing this leads to more loosely connected
        // dungeons.
        const extraConnectorChance = 50

        // Increasing this allows rooms to be larger.
        const roomExtraSize = 0

        const windingPercent = 50

        const _rooms = []

        // The index of the current region being carved.
        let _currentRegion = -1

        let stage

        const n = new Victor(0, 1)
        const e = new Victor(1, 0)
        const s = new Victor(0, -1)
        const w = new Victor(-1, 0)

        // The four cardinal directions: north, south, east, and west.
        const cardinalDirections = [n, e, s, w]

        const bindStage = givenStage => {
          stage = givenStage
        }

        const _tiles = []

        /**
   * @desc returns a tile at the provided coordinates
   *
   * @param {Number} x - The x coordinate to retrieve
   * @param {Number} y - The y coordinate to retrieve
   *
   * @returns {Object} - A Tile object
   */
        const getTile = (x, y) => {
          return _tiles[x][y]
        }

        /**
   * @desc Sets a tile's type and region. This function will thrown an error if
   * the tile doesn't exist.
   *
   * @param {Number} x - The x coordinate of the tile to set
   * @param {Number} y - The y coordinate of the tile to set
   * @param {String} type - The type to set on the tile
   *
   * @returns {Object} - The Tile object or null if the tile was not found
   *
   */
        const setTile = (x, y, type) => {
          if (_tiles[x] && _tiles[x][y]) {
            _tiles[x][y].type = type
            _tiles[x][y].region = _currentRegion

            return _tiles[x][y]
          }

          throw new RangeError(`tile at ${x}, ${y} is unreachable`)
        }

        /**
   * @desc Generates tile data to the dimension of the stage.
   *
   * @param {String} type - The tile type to set on newly created tiles
   *
   * @returns {Array} - The _tiles array
   */
        const fill = type => {
          let neighbours = []
          let nesw = {}
          let x
          let y

          for (x = 0; x < stage.width; x++) {
            _tiles.push([])
            for (y = 0; y < stage.height; y++) {
              _tiles[x].push(new Tile(type))
            }
          }

          for (x = 0; x < stage.width; x++) {
            for (y = 0; y < stage.height; y++) {
              neighbours = []
              nesw = {}
              if (_tiles[x][y - 1]) {
                neighbours.push(_tiles[x][y - 1])
                nesw.north = _tiles[x][y - 1]
              }
              if (_tiles[x + 1] && _tiles[x + 1][y - 1]) {
                neighbours.push(_tiles[x + 1][y - 1])
              }
              if (_tiles[x + 1] && _tiles[x + 1][y]) {
                neighbours.push(_tiles[x + 1][y])
                nesw.east = _tiles[x + 1][y]
              }
              if (_tiles[x + 1] && _tiles[x + 1][y + 1]) {
                neighbours.push(_tiles[x + 1][y + 1])
              }
              if (_tiles[x] && _tiles[x][y + 1]) {
                neighbours.push(_tiles[x][y + 1])
                nesw.south = _tiles[x][y + 1]
              }
              if (_tiles[x - 1] && _tiles[x - 1][y + 1]) {
                neighbours.push(_tiles[x - 1][y + 1])
              }
              if (_tiles[x - 1] && _tiles[x - 1][y]) {
                neighbours.push(_tiles[x - 1][y])
                nesw.west = _tiles[x - 1][y]
              }
              if (_tiles[x - 1] && _tiles[x - 1][y - 1]) {
                neighbours.push(_tiles[x - 1][y - 1])
              }
              _tiles[x][y].setNeighbours(neighbours)
              _tiles[x][y].nesw = nesw
            }
          }

          return _tiles
        }

        /**
   * @desc Master function for generating a dungeon
   *
   * @param {Object} stage - An object with a width key and a height key. Used
   * to determine the size of the dungeon. Must be odd with and height.
   * @param {Boolean} debug - outputs debug info if set to true
   *
   * @returns {Object} - Tile information for the dungeon
   */
        const generate = (stage, debug = false) => {
          const startDate = Date.now()
          if (stage.width % 2 === 0 || stage.height % 2 === 0) {
            throw new Error('The stage must be odd-sized.')
          }

          bindStage(stage)

          fill('wall')

          _addRooms()

          // Fill in all of the empty space with mazes.
          for (let y = 1; y < stage.height; y += 2) {
            for (let x = 1; x < stage.width; x += 2) {
            // Skip the maze generation if the tile is already carved
              if (getTile(x, y).type === 'floor') {
                continue
              }
              _growMaze(x, y)
            }
          }

          _connectRegions()

          _removeDeadEnds()

          const endDate = Date.now()

          if (debug) {
            console.log('Dungeon generated in ' + (endDate - startDate) + 'ms')
          }

          return {
            rooms: _rooms,
            tiles: _tiles
          }
        }

        /**
   * @desc Implementation of the "growing tree" algorithm from here:
   * http://www.astrolog.org/labyrnth/algrithm.htm.
   *
   * @param {Number} startX - The x coordinate to start at
   * @param {Number} startY - The y coordinate to start at
   *
   * @returns {void}
   */
        const _growMaze = (startX, startY) => {
          const cells = []
          let lastDir

          if (_tiles[startX][startY].neighbours.filter(x => x.type === 'floor').length > 0) {
            return
          }

          _startRegion()

          _carve(startX, startY)

          cells.push(new Victor(startX, startY))

          let count = 0

          while (cells.length && count < 500) {
            count++
            const cell = cells[cells.length - 1]

            // See which adjacent cells are open.
            const unmadeCells = []

            for (const dir of cardinalDirections) {
              if (_canCarve(cell, dir)) {
                unmadeCells.push(dir)
              }
            }

            if (unmadeCells.length) {
            // Based on how "windy" passages are, try to prefer carving in the
            // same direction.
              var dir
              const stringifiedCells = unmadeCells.map(v => v.toString())
              if (lastDir && stringifiedCells.indexOf(lastDir.toString()) > -1 && _.random(1, 100) > windingPercent) {
                dir = lastDir.clone()
              } else {
                const rand = _.random(0, unmadeCells.length - 1)
                dir = unmadeCells[rand].clone()
              }

              const carveLoc1 = cell.clone().add(dir).toObject()
              _carve(carveLoc1.x, carveLoc1.y)

              const carveLoc2 = cell.clone().add(dir).add(dir).toObject()
              _carve(carveLoc2.x, carveLoc2.y)

              cells.push(cell.clone().add(dir).add(dir))

              lastDir = dir.clone()
            } else {
            // No adjacent uncarved cells.
              cells.pop()

              // This path has ended.
              lastDir = null
            }
          }
        }

        /**
   * @desc Creates rooms in the dungeon by repeatedly creating random rooms and
   * seeing if they overlap. Rooms that overlap are discarded. This process is
   * repeated until it hits the maximum tries determined by the 'numRoomTries'
   * variable.
   *
   * @returns {void}
   */
        const _addRooms = () => {
          for (let i = 0; i < numRoomTries; i++) {
          // Pick a random room size. The funny math here does two things:
          // - It makes sure rooms are odd-sized to line up with maze.
          // - It avoids creating rooms that are too rectangular: too tall and
          //   narrow or too wide and flat.
            const size = _.random(1, 3 + roomExtraSize) * 2 + 1
            const rectangularity = _.random(0, 1 + Math.floor(size / 2)) * 2
            let width = size
            let height = size
            if (_oneIn(2)) {
              width += rectangularity
            } else {
              height += rectangularity
            }

            let x = _.random(0, Math.floor((stage.width - width) / 2)) * 2 + 1
            let y = _.random(0, Math.floor((stage.height - height) / 2)) * 2 + 1

            if (x > stage.width - width) {
              x = stage.width - width - 1
            }

            if (y > stage.height - height) {
              y = stage.height - height - 1
            }

            const room = new Room(x, y, width, height)

            let overlaps = false

            for (const other of _rooms) {
              if (room.intersects(other)) {
                overlaps = true
                break
              }
            }

            if (overlaps) {
              continue
            }

            _rooms.push(room)

            _startRegion()

            // Convert room tiles to floor
            carveArea(x, y, width, height)
          }
        }

        /**
   * @desc converts an area of tiles to floor type
   *
   * @param {Number} x - The starting x coordinate
   * @param {Number} y - The starting y coordinate
   * @param {Number} width - The width of the area to carve
   * @param {Number} height - The height of the area to carve
   *
   * @returns {void}
   */
        const carveArea = (x, y, width, height) => {
          for (let i = x; i < x + width; i++) {
            for (let j = y; j < y + height; j++) {
              _carve(i, j)
            }
          }
        }

        /**
   * @desc Creates doorways between each generated region of tiles
   *
   * @return {void}
   */
        const _connectRegions = () => {
          const regionConnections = {}
          _tiles.forEach(row => {
            row.forEach(tile => {
              if (tile.type === 'floor') {
                return
              }

              const tileRegions = _.unique(_.values(tile.nesw).map(x => x.region).filter(x => !_.isUndefined(x)))
              if (tileRegions.length <= 1) {
                return
              }

              const key = tileRegions.join('-')
              if (!regionConnections[key]) {
                regionConnections[key] = []
              }
              regionConnections[key].push(tile)
            })
          })

          _.each(regionConnections, connections => {
            const index = _.random(0, connections.length - 1)
            connections[index].type = 'door'
            connections.splice(index, 1)

            // Occasional open up additional connections
            connections.forEach(conn => {
              if (_oneIn(extraConnectorChance)) {
                conn.type = 'door'
              }
            })
          })
        }

        /**
   * @desc Helper function for calculating random chance. The higher the number
   * provided the less likely this value is to return true.
   *
   * @param {Number} num - The ceiling number that could be calculated
   *
   * @returns {Boolean} - True if the function rolled a one
   *
   * @example
   * _oneIn(50); // - Has a 1 in 50 chance of returning true
   */
        const _oneIn = num => {
          return _.random(1, num) === 1
        }

        /**
   * @desc Fills in dead ends in the dungeon with wall tiles
   *
   * @returns {void}
   */
        const _removeDeadEnds = () => {
          let done = false

          const cycle = () => {
            let done = true
            _tiles.forEach(row => {
              row.forEach(tile => {
              // If it only has one exit, it's a dead end --> fill it in!
                if (tile.type === 'wall') {
                  return
                }
                if (_.values(tile.nesw).filter(t => t.type !== 'wall').length <= 1) {
                  tile.type = 'wall'
                  done = false
                }
              })
            })

            return done
          }

          while (!done) {
            done = true
            done = cycle()
          }
        }

        /**
   * @desc Gets whether or not an opening can be carved from the given starting
   * [Cell] at [pos] to the adjacent Cell facing [direction]. Returns `true`
   * if the starting Cell is in bounds and the destination Cell is filled
   * (or out of bounds).</returns>
   *
   * @param {Victor} cell - Victor JS vector object
   * @param {Victor} direction - Victor JS vector object indicating direction
   *
   * @return {Boolean} - true if the path can be carved
   */
        const _canCarve = (cell, direction) => {
        // Must end in bounds.
          const end = cell.clone().add(direction).add(direction).add(direction).toObject()

          if (!_tiles[end.x] || !_tiles[end.x][end.y]) {
            return false
          }

          if (getTile(end.x, end.y).type !== 'wall') {
            return false
          }

          // Destination must not be open.
          const dest = cell.clone().add(direction).add(direction).toObject()
          return getTile(dest.x, dest.y).type !== 'floor'
        }

        /**
   * @desc Increments the current region. Typically called every time a new area
   * starts being carved
   *
   * @returns {Number} - The current region number
   */
        const _startRegion = () => {
          _currentRegion++
          return _currentRegion
        }

        /**
   * @desc Changes the Tile at a given coordinate to a provided type. Typically
   * used to change the type to 'floor'
   *
   * @param {Number} x - The x coordinate to change
   * @param {Number} y - The y coordinate to change
   * @param {String} type - The type to change the tile to. Defaults to 'floor'
   *
   * @returns {void}
   */
        const _carve = (x, y, type = 'floor') => {
          setTile(x, y, type)
        }

        return {
          generate
        }
      }

      const generate = options => {
        return new Dungeon().generate(options)
      }

      module.exports = {
        generate
      }
    }, { './room': 2, './tile': 3, underscore: 4, victor: 5 }],
    2: [function (require, module, exports) {
      'use strict'

      /**
 * @desc Helper class for drawing rooms when generating dungeons
 * @constructor
 *
 * @param {Number} x - The x coordinate of the top side of the room
 * @param {Number} y - The y coordinate of the left hand side of the room
 * @param {Number} width - The width of the room
 * @param {Number} height - The height of the room
 */

      const Room = function Room (x, y, width, height) {
        this.x = x
        this.y = y
        this.width = width
        this.height = height
      }

      /**
 * @desc Returns the bounding box for this room
 * @function
 *
 * @returns {Object} - Bounding box object containing a top, right, bottom and
 * left value.
 */
      Room.prototype.getBoundingBox = function getBoundingBox () {
        return {
          top: this.y,
          right: this.x + this.width,
          bottom: this.y + this.height,
          left: this.x
        }
      }

      /**
 * @desc Compares this room with an entity that has a bounding box method to see
 * if they intersect.
 *
 * @param {Object} other - An object with a getBoundingBox() method
 *
 * @returns {Boolean} - true if there is an intersection
 */
      Room.prototype.intersects = function intersects (other) {
        if (!other.getBoundingBox) {
          throw new Error('Given entity has no method getBoundingBox')
        }
        const r1 = this.getBoundingBox()
        const r2 = other.getBoundingBox()

        return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top)
      }

      module.exports = Room
    }, {}],
    3: [function (require, module, exports) {
      'use strict'

      /**
 * @desc Class for a single tilein a dungeon
 * @constructor
 *
 * @param {String} type - The type of tile, e.g. 'wall', 'floor'
 */

      const Tile = function Tile (type) {
        this.type = type
        this.neighbours = []
      }

      /**
 * @desc Sets an array containing this tiles immediate neighbours
 *
 * @param {Object[]} neighbours - An array of neighbouring Tiles
 *
 * @return {Object} - returns the Tile object, useful for chaining
 */
      Tile.prototype.setNeighbours = function (neighbours) {
        this.neighbours = neighbours
        return this
      }

      module.exports = Tile
    }, {}],
    4: [function (require, module, exports) {
      (function (global) {
        //     Underscore.js 1.9.1
        //     http://underscorejs.org
        //     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
        //     Underscore may be freely distributed under the MIT license.

        (function () {
        // Baseline setup
          // --------------

          // Establish the root object, `window` (`self`) in the browser, `global`
          // on the server, or `this` in some virtual machines. We use `self`
          // instead of `window` for `WebWorker` support.
          const root = typeof self === 'object' && self.self === self && self ||
            typeof global === 'object' && global.global === global && global ||
            this ||
            {}

          // Save the previous value of the `_` variable.
          const previousUnderscore = root._

          // Save bytes in the minified (but not gzipped) version:
          const ArrayProto = Array.prototype; const ObjProto = Object.prototype
          const SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null

          // Create quick reference variables for speed access to core prototypes.
          const push = ArrayProto.push
          const slice = ArrayProto.slice
          const toString = ObjProto.toString
          const hasOwnProperty = ObjProto.hasOwnProperty

          // All **ECMAScript 5** native function implementations that we hope to use
          // are declared here.
          const nativeIsArray = Array.isArray
          const nativeKeys = Object.keys
          const nativeCreate = Object.create

          // Naked function reference for surrogate-prototype-swapping.
          const Ctor = function () {}

          // Create a safe reference to the Underscore object for use below.
          var _ = function (obj) {
            if (obj instanceof _) return obj
            if (!(this instanceof _)) return new _(obj)
            this._wrapped = obj
          }

          // Export the Underscore object for **Node.js**, with
          // backwards-compatibility for their old module API. If we're in
          // the browser, add `_` as a global object.
          // (`nodeType` is checked to ensure that `module`
          // and `exports` are not HTML elements.)
          if (typeof exports !== 'undefined' && !exports.nodeType) {
            if (typeof module !== 'undefined' && !module.nodeType && module.exports) {
              exports = module.exports = _
            }
            exports._ = _
          } else {
            root._ = _
          }

          // Current version.
          _.VERSION = '1.9.1'

          // Internal function that returns an efficient (for current engines) version
          // of the passed-in callback, to be repeatedly applied in other Underscore
          // functions.
          const optimizeCb = function (func, context, argCount) {
            if (context === void 0) return func
            switch (argCount == null ? 3 : argCount) {
              case 1: return function (value) {
                return func.call(context, value)
              }
                // The 2-argument case is omitted because we’re not using it.
              case 3: return function (value, index, collection) {
                return func.call(context, value, index, collection)
              }
              case 4: return function (accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection)
              }
            }
            return function () {
              return func.apply(context, arguments)
            }
          }

          let builtinIteratee

          // An internal function to generate callbacks that can be applied to each
          // element in a collection, returning the desired result — either `identity`,
          // an arbitrary callback, a property matcher, or a property accessor.
          const cb = function (value, context, argCount) {
            if (_.iteratee !== builtinIteratee) return _.iteratee(value, context)
            if (value == null) return _.identity
            if (_.isFunction(value)) return optimizeCb(value, context, argCount)
            if (_.isObject(value) && !_.isArray(value)) return _.matcher(value)
            return _.property(value)
          }

          // External wrapper for our callback generator. Users may customize
          // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
          // This abstraction hides the internal-only argCount argument.
          _.iteratee = builtinIteratee = function (value, context) {
            return cb(value, context, Infinity)
          }

          // Some functions take a variable number of arguments, or a few expected
          // arguments at the beginning and then a variable number of values to operate
          // on. This helper accumulates all remaining arguments past the function’s
          // argument length (or an explicit `startIndex`), into an array that becomes
          // the last argument. Similar to ES6’s "rest parameter".
          const restArguments = function (func, startIndex) {
            startIndex = startIndex == null ? func.length - 1 : +startIndex
            return function () {
              const length = Math.max(arguments.length - startIndex, 0)
              const rest = Array(length)
              let index = 0
              for (; index < length; index++) {
                rest[index] = arguments[index + startIndex]
              }
              switch (startIndex) {
                case 0: return func.call(this, rest)
                case 1: return func.call(this, arguments[0], rest)
                case 2: return func.call(this, arguments[0], arguments[1], rest)
              }
              const args = Array(startIndex + 1)
              for (index = 0; index < startIndex; index++) {
                args[index] = arguments[index]
              }
              args[startIndex] = rest
              return func.apply(this, args)
            }
          }

          // An internal function for creating a new object that inherits from another.
          const baseCreate = function (prototype) {
            if (!_.isObject(prototype)) return {}
            if (nativeCreate) return nativeCreate(prototype)
            Ctor.prototype = prototype
            const result = new Ctor()
            Ctor.prototype = null
            return result
          }

          const shallowProperty = function (key) {
            return function (obj) {
              return obj == null ? void 0 : obj[key]
            }
          }

          const has = function (obj, path) {
            return obj != null && hasOwnProperty.call(obj, path)
          }

          const deepGet = function (obj, path) {
            const length = path.length
            for (let i = 0; i < length; i++) {
              if (obj == null) return void 0
              obj = obj[path[i]]
            }
            return length ? obj : void 0
          }

          // Helper for collection methods to determine whether a collection
          // should be iterated as an array or as an object.
          // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
          // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
          const MAX_ARRAY_INDEX = Math.pow(2, 53) - 1
          const getLength = shallowProperty('length')
          const isArrayLike = function (collection) {
            const length = getLength(collection)
            return typeof length === 'number' && length >= 0 && length <= MAX_ARRAY_INDEX
          }

          // Collection Functions
          // --------------------

          // The cornerstone, an `each` implementation, aka `forEach`.
          // Handles raw objects in addition to array-likes. Treats all
          // sparse array-likes as if they were dense.
          _.each = _.forEach = function (obj, iteratee, context) {
            iteratee = optimizeCb(iteratee, context)
            let i, length
            if (isArrayLike(obj)) {
              for (i = 0, length = obj.length; i < length; i++) {
                iteratee(obj[i], i, obj)
              }
            } else {
              const keys = _.keys(obj)
              for (i = 0, length = keys.length; i < length; i++) {
                iteratee(obj[keys[i]], keys[i], obj)
              }
            }
            return obj
          }

          // Return the results of applying the iteratee to each element.
          _.map = _.collect = function (obj, iteratee, context) {
            iteratee = cb(iteratee, context)
            const keys = !isArrayLike(obj) && _.keys(obj)
            const length = (keys || obj).length
            const results = Array(length)
            for (let index = 0; index < length; index++) {
              const currentKey = keys ? keys[index] : index
              results[index] = iteratee(obj[currentKey], currentKey, obj)
            }
            return results
          }

          // Create a reducing function iterating left or right.
          const createReduce = function (dir) {
            // Wrap code that reassigns argument variables in a separate function than
            // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
            const reducer = function (obj, iteratee, memo, initial) {
              const keys = !isArrayLike(obj) && _.keys(obj)
              const length = (keys || obj).length
              let index = dir > 0 ? 0 : length - 1
              if (!initial) {
                memo = obj[keys ? keys[index] : index]
                index += dir
              }
              for (; index >= 0 && index < length; index += dir) {
                const currentKey = keys ? keys[index] : index
                memo = iteratee(memo, obj[currentKey], currentKey, obj)
              }
              return memo
            }

            return function (obj, iteratee, memo, context) {
              const initial = arguments.length >= 3
              return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial)
            }
          }

          // **Reduce** builds up a single result from a list of values, aka `inject`,
          // or `foldl`.
          _.reduce = _.foldl = _.inject = createReduce(1)

          // The right-associative version of reduce, also known as `foldr`.
          _.reduceRight = _.foldr = createReduce(-1)

          // Return the first value which passes a truth test. Aliased as `detect`.
          _.find = _.detect = function (obj, predicate, context) {
            const keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey
            const key = keyFinder(obj, predicate, context)
            if (key !== void 0 && key !== -1) return obj[key]
          }

          // Return all the elements that pass a truth test.
          // Aliased as `select`.
          _.filter = _.select = function (obj, predicate, context) {
            const results = []
            predicate = cb(predicate, context)
            _.each(obj, function (value, index, list) {
              if (predicate(value, index, list)) results.push(value)
            })
            return results
          }

          // Return all the elements for which a truth test fails.
          _.reject = function (obj, predicate, context) {
            return _.filter(obj, _.negate(cb(predicate)), context)
          }

          // Determine whether all of the elements match a truth test.
          // Aliased as `all`.
          _.every = _.all = function (obj, predicate, context) {
            predicate = cb(predicate, context)
            const keys = !isArrayLike(obj) && _.keys(obj)
            const length = (keys || obj).length
            for (let index = 0; index < length; index++) {
              const currentKey = keys ? keys[index] : index
              if (!predicate(obj[currentKey], currentKey, obj)) return false
            }
            return true
          }

          // Determine if at least one element in the object matches a truth test.
          // Aliased as `any`.
          _.some = _.any = function (obj, predicate, context) {
            predicate = cb(predicate, context)
            const keys = !isArrayLike(obj) && _.keys(obj)
            const length = (keys || obj).length
            for (let index = 0; index < length; index++) {
              const currentKey = keys ? keys[index] : index
              if (predicate(obj[currentKey], currentKey, obj)) return true
            }
            return false
          }

          // Determine if the array or object contains a given item (using `===`).
          // Aliased as `includes` and `include`.
          _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
            if (!isArrayLike(obj)) obj = _.values(obj)
            if (typeof fromIndex !== 'number' || guard) fromIndex = 0
            return _.indexOf(obj, item, fromIndex) >= 0
          }

          // Invoke a method (with arguments) on every item in a collection.
          _.invoke = restArguments(function (obj, path, args) {
            let contextPath, func
            if (_.isFunction(path)) {
              func = path
            } else if (_.isArray(path)) {
              contextPath = path.slice(0, -1)
              path = path[path.length - 1]
            }
            return _.map(obj, function (context) {
              let method = func
              if (!method) {
                if (contextPath && contextPath.length) {
                  context = deepGet(context, contextPath)
                }
                if (context == null) return void 0
                method = context[path]
              }
              return method == null ? method : method.apply(context, args)
            })
          })

          // Convenience version of a common use case of `map`: fetching a property.
          _.pluck = function (obj, key) {
            return _.map(obj, _.property(key))
          }

          // Convenience version of a common use case of `filter`: selecting only objects
          // containing specific `key:value` pairs.
          _.where = function (obj, attrs) {
            return _.filter(obj, _.matcher(attrs))
          }

          // Convenience version of a common use case of `find`: getting the first object
          // containing specific `key:value` pairs.
          _.findWhere = function (obj, attrs) {
            return _.find(obj, _.matcher(attrs))
          }

          // Return the maximum element (or element-based computation).
          _.max = function (obj, iteratee, context) {
            let result = -Infinity; let lastComputed = -Infinity
            let value; let computed
            if (iteratee == null || typeof iteratee === 'number' && typeof obj[0] !== 'object' && obj != null) {
              obj = isArrayLike(obj) ? obj : _.values(obj)
              for (let i = 0, length = obj.length; i < length; i++) {
                value = obj[i]
                if (value != null && value > result) {
                  result = value
                }
              }
            } else {
              iteratee = cb(iteratee, context)
              _.each(obj, function (v, index, list) {
                computed = iteratee(v, index, list)
                if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                  result = v
                  lastComputed = computed
                }
              })
            }
            return result
          }

          // Return the minimum element (or element-based computation).
          _.min = function (obj, iteratee, context) {
            let result = Infinity; let lastComputed = Infinity
            let value; let computed
            if (iteratee == null || typeof iteratee === 'number' && typeof obj[0] !== 'object' && obj != null) {
              obj = isArrayLike(obj) ? obj : _.values(obj)
              for (let i = 0, length = obj.length; i < length; i++) {
                value = obj[i]
                if (value != null && value < result) {
                  result = value
                }
              }
            } else {
              iteratee = cb(iteratee, context)
              _.each(obj, function (v, index, list) {
                computed = iteratee(v, index, list)
                if (computed < lastComputed || computed === Infinity && result === Infinity) {
                  result = v
                  lastComputed = computed
                }
              })
            }
            return result
          }

          // Shuffle a collection.
          _.shuffle = function (obj) {
            return _.sample(obj, Infinity)
          }

          // Sample **n** random values from a collection using the modern version of the
          // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
          // If **n** is not specified, returns a single random element.
          // The internal `guard` argument allows it to work with `map`.
          _.sample = function (obj, n, guard) {
            if (n == null || guard) {
              if (!isArrayLike(obj)) obj = _.values(obj)
              return obj[_.random(obj.length - 1)]
            }
            const sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj)
            const length = getLength(sample)
            n = Math.max(Math.min(n, length), 0)
            const last = length - 1
            for (let index = 0; index < n; index++) {
              const rand = _.random(index, last)
              const temp = sample[index]
              sample[index] = sample[rand]
              sample[rand] = temp
            }
            return sample.slice(0, n)
          }

          // Sort the object's values by a criterion produced by an iteratee.
          _.sortBy = function (obj, iteratee, context) {
            let index = 0
            iteratee = cb(iteratee, context)
            return _.pluck(_.map(obj, function (value, key, list) {
              return {
                value: value,
                index: index++,
                criteria: iteratee(value, key, list)
              }
            }).sort(function (left, right) {
              const a = left.criteria
              const b = right.criteria
              if (a !== b) {
                if (a > b || a === void 0) return 1
                if (a < b || b === void 0) return -1
              }
              return left.index - right.index
            }), 'value')
          }

          // An internal function used for aggregate "group by" operations.
          const group = function (behavior, partition) {
            return function (obj, iteratee, context) {
              const result = partition ? [[], []] : {}
              iteratee = cb(iteratee, context)
              _.each(obj, function (value, index) {
                const key = iteratee(value, index, obj)
                behavior(result, value, key)
              })
              return result
            }
          }

          // Groups the object's values by a criterion. Pass either a string attribute
          // to group by, or a function that returns the criterion.
          _.groupBy = group(function (result, value, key) {
            if (has(result, key)) result[key].push(value); else result[key] = [value]
          })

          // Indexes the object's values by a criterion, similar to `groupBy`, but for
          // when you know that your index values will be unique.
          _.indexBy = group(function (result, value, key) {
            result[key] = value
          })

          // Counts instances of an object that group by a certain criterion. Pass
          // either a string attribute to count by, or a function that returns the
          // criterion.
          _.countBy = group(function (result, value, key) {
            if (has(result, key)) result[key]++; else result[key] = 1
          })

          const reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g
          // Safely create a real, live array from anything iterable.
          _.toArray = function (obj) {
            if (!obj) return []
            if (_.isArray(obj)) return slice.call(obj)
            if (_.isString(obj)) {
              // Keep surrogate pair characters together
              return obj.match(reStrSymbol)
            }
            if (isArrayLike(obj)) return _.map(obj, _.identity)
            return _.values(obj)
          }

          // Return the number of elements in an object.
          _.size = function (obj) {
            if (obj == null) return 0
            return isArrayLike(obj) ? obj.length : _.keys(obj).length
          }

          // Split a collection into two arrays: one whose elements all satisfy the given
          // predicate, and one whose elements all do not satisfy the predicate.
          _.partition = group(function (result, value, pass) {
            result[pass ? 0 : 1].push(value)
          }, true)

          // Array Functions
          // ---------------

          // Get the first element of an array. Passing **n** will return the first N
          // values in the array. Aliased as `head` and `take`. The **guard** check
          // allows it to work with `_.map`.
          _.first = _.head = _.take = function (array, n, guard) {
            if (array == null || array.length < 1) return n == null ? void 0 : []
            if (n == null || guard) return array[0]
            return _.initial(array, array.length - n)
          }

          // Returns everything but the last entry of the array. Especially useful on
          // the arguments object. Passing **n** will return all the values in
          // the array, excluding the last N.
          _.initial = function (array, n, guard) {
            return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)))
          }

          // Get the last element of an array. Passing **n** will return the last N
          // values in the array.
          _.last = function (array, n, guard) {
            if (array == null || array.length < 1) return n == null ? void 0 : []
            if (n == null || guard) return array[array.length - 1]
            return _.rest(array, Math.max(0, array.length - n))
          }

          // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
          // Especially useful on the arguments object. Passing an **n** will return
          // the rest N values in the array.
          _.rest = _.tail = _.drop = function (array, n, guard) {
            return slice.call(array, n == null || guard ? 1 : n)
          }

          // Trim out all falsy values from an array.
          _.compact = function (array) {
            return _.filter(array, Boolean)
          }

          // Internal implementation of a recursive `flatten` function.
          var flatten = function (input, shallow, strict, output) {
            output = output || []
            let idx = output.length
            for (let i = 0, length = getLength(input); i < length; i++) {
              const value = input[i]
              if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                // Flatten current level of array or arguments object.
                if (shallow) {
                  let j = 0; const len = value.length
                  while (j < len) output[idx++] = value[j++]
                } else {
                  flatten(value, shallow, strict, output)
                  idx = output.length
                }
              } else if (!strict) {
                output[idx++] = value
              }
            }
            return output
          }

          // Flatten out an array, either recursively (by default), or just one level.
          _.flatten = function (array, shallow) {
            return flatten(array, shallow, false)
          }

          // Return a version of the array that does not contain the specified value(s).
          _.without = restArguments(function (array, otherArrays) {
            return _.difference(array, otherArrays)
          })

          // Produce a duplicate-free version of the array. If the array has already
          // been sorted, you have the option of using a faster algorithm.
          // The faster algorithm will not work with an iteratee if the iteratee
          // is not a one-to-one function, so providing an iteratee will disable
          // the faster algorithm.
          // Aliased as `unique`.
          _.uniq = _.unique = function (array, isSorted, iteratee, context) {
            if (!_.isBoolean(isSorted)) {
              context = iteratee
              iteratee = isSorted
              isSorted = false
            }
            if (iteratee != null) iteratee = cb(iteratee, context)
            const result = []
            let seen = []
            for (let i = 0, length = getLength(array); i < length; i++) {
              const value = array[i]
              const computed = iteratee ? iteratee(value, i, array) : value
              if (isSorted && !iteratee) {
                if (!i || seen !== computed) result.push(value)
                seen = computed
              } else if (iteratee) {
                if (!_.contains(seen, computed)) {
                  seen.push(computed)
                  result.push(value)
                }
              } else if (!_.contains(result, value)) {
                result.push(value)
              }
            }
            return result
          }

          // Produce an array that contains the union: each distinct element from all of
          // the passed-in arrays.
          _.union = restArguments(function (arrays) {
            return _.uniq(flatten(arrays, true, true))
          })

          // Produce an array that contains every item shared between all the
          // passed-in arrays.
          _.intersection = function (array) {
            const result = []
            const argsLength = arguments.length
            for (let i = 0, length = getLength(array); i < length; i++) {
              const item = array[i]
              if (_.contains(result, item)) continue
              var j
              for (j = 1; j < argsLength; j++) {
                if (!_.contains(arguments[j], item)) break
              }
              if (j === argsLength) result.push(item)
            }
            return result
          }

          // Take the difference between one array and a number of other arrays.
          // Only the elements present in just the first array will remain.
          _.difference = restArguments(function (array, rest) {
            rest = flatten(rest, true, true)
            return _.filter(array, function (value) {
              return !_.contains(rest, value)
            })
          })

          // Complement of _.zip. Unzip accepts an array of arrays and groups
          // each array's elements on shared indices.
          _.unzip = function (array) {
            const length = array && _.max(array, getLength).length || 0
            const result = Array(length)

            for (let index = 0; index < length; index++) {
              result[index] = _.pluck(array, index)
            }
            return result
          }

          // Zip together multiple lists into a single array -- elements that share
          // an index go together.
          _.zip = restArguments(_.unzip)

          // Converts lists into objects. Pass either a single array of `[key, value]`
          // pairs, or two parallel arrays of the same length -- one of keys, and one of
          // the corresponding values. Passing by pairs is the reverse of _.pairs.
          _.object = function (list, values) {
            const result = {}
            for (let i = 0, length = getLength(list); i < length; i++) {
              if (values) {
                result[list[i]] = values[i]
              } else {
                result[list[i][0]] = list[i][1]
              }
            }
            return result
          }

          // Generator function to create the findIndex and findLastIndex functions.
          const createPredicateIndexFinder = function (dir) {
            return function (array, predicate, context) {
              predicate = cb(predicate, context)
              const length = getLength(array)
              let index = dir > 0 ? 0 : length - 1
              for (; index >= 0 && index < length; index += dir) {
                if (predicate(array[index], index, array)) return index
              }
              return -1
            }
          }

          // Returns the first index on an array-like that passes a predicate test.
          _.findIndex = createPredicateIndexFinder(1)
          _.findLastIndex = createPredicateIndexFinder(-1)

          // Use a comparator function to figure out the smallest index at which
          // an object should be inserted so as to maintain order. Uses binary search.
          _.sortedIndex = function (array, obj, iteratee, context) {
            iteratee = cb(iteratee, context, 1)
            const value = iteratee(obj)
            let low = 0; let high = getLength(array)
            while (low < high) {
              const mid = Math.floor((low + high) / 2)
              if (iteratee(array[mid]) < value) low = mid + 1; else high = mid
            }
            return low
          }

          // Generator function to create the indexOf and lastIndexOf functions.
          const createIndexFinder = function (dir, predicateFind, sortedIndex) {
            return function (array, item, idx) {
              let i = 0; let length = getLength(array)
              if (typeof idx === 'number') {
                if (dir > 0) {
                  i = idx >= 0 ? idx : Math.max(idx + length, i)
                } else {
                  length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1
                }
              } else if (sortedIndex && idx && length) {
                idx = sortedIndex(array, item)
                return array[idx] === item ? idx : -1
              }
              if (item !== item) {
                idx = predicateFind(slice.call(array, i, length), _.isNaN)
                return idx >= 0 ? idx + i : -1
              }
              for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
                if (array[idx] === item) return idx
              }
              return -1
            }
          }

          // Return the position of the first occurrence of an item in an array,
          // or -1 if the item is not included in the array.
          // If the array is large and already in sort order, pass `true`
          // for **isSorted** to use binary search.
          _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex)
          _.lastIndexOf = createIndexFinder(-1, _.findLastIndex)

          // Generate an integer Array containing an arithmetic progression. A port of
          // the native Python `range()` function. See
          // [the Python documentation](http://docs.python.org/library/functions.html#range).
          _.range = function (start, stop, step) {
            if (stop == null) {
              stop = start || 0
              start = 0
            }
            if (!step) {
              step = stop < start ? -1 : 1
            }

            const length = Math.max(Math.ceil((stop - start) / step), 0)
            const range = Array(length)

            for (let idx = 0; idx < length; idx++, start += step) {
              range[idx] = start
            }

            return range
          }

          // Chunk a single array into multiple arrays, each containing `count` or fewer
          // items.
          _.chunk = function (array, count) {
            if (count == null || count < 1) return []
            const result = []
            let i = 0; const length = array.length
            while (i < length) {
              result.push(slice.call(array, i, i += count))
            }
            return result
          }

          // Function (ahem) Functions
          // ------------------

          // Determines whether to execute a function as a constructor
          // or a normal function with the provided arguments.
          const executeBound = function (sourceFunc, boundFunc, context, callingContext, args) {
            if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args)
            const self = baseCreate(sourceFunc.prototype)
            const result = sourceFunc.apply(self, args)
            if (_.isObject(result)) return result
            return self
          }

          // Create a function bound to a given object (assigning `this`, and arguments,
          // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
          // available.
          _.bind = restArguments(function (func, context, args) {
            if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function')
            var bound = restArguments(function (callArgs) {
              return executeBound(func, bound, context, this, args.concat(callArgs))
            })
            return bound
          })

          // Partially apply a function by creating a version that has had some of its
          // arguments pre-filled, without changing its dynamic `this` context. _ acts
          // as a placeholder by default, allowing any combination of arguments to be
          // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
          _.partial = restArguments(function (func, boundArgs) {
            const placeholder = _.partial.placeholder
            var bound = function () {
              let position = 0; const length = boundArgs.length
              const args = Array(length)
              for (let i = 0; i < length; i++) {
                args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i]
              }
              while (position < arguments.length) args.push(arguments[position++])
              return executeBound(func, bound, this, this, args)
            }
            return bound
          })

          _.partial.placeholder = _

          // Bind a number of an object's methods to that object. Remaining arguments
          // are the method names to be bound. Useful for ensuring that all callbacks
          // defined on an object belong to it.
          _.bindAll = restArguments(function (obj, keys) {
            keys = flatten(keys, false, false)
            let index = keys.length
            if (index < 1) throw new Error('bindAll must be passed function names')
            while (index--) {
              const key = keys[index]
              obj[key] = _.bind(obj[key], obj)
            }
          })

          // Memoize an expensive function by storing its results.
          _.memoize = function (func, hasher) {
            var memoize = function (key) {
              const cache = memoize.cache
              const address = '' + (hasher ? hasher.apply(this, arguments) : key)
              if (!has(cache, address)) cache[address] = func.apply(this, arguments)
              return cache[address]
            }
            memoize.cache = {}
            return memoize
          }

          // Delays a function for the given number of milliseconds, and then calls
          // it with the arguments supplied.
          _.delay = restArguments(function (func, wait, args) {
            return setTimeout(function () {
              return func.apply(null, args)
            }, wait)
          })

          // Defers a function, scheduling it to run after the current call stack has
          // cleared.
          _.defer = _.partial(_.delay, _, 1)

          // Returns a function, that, when invoked, will only be triggered at most once
          // during a given window of time. Normally, the throttled function will run
          // as much as it can, without ever going more than once per `wait` duration;
          // but if you'd like to disable the execution on the leading edge, pass
          // `{leading: false}`. To disable execution on the trailing edge, ditto.
          _.throttle = function (func, wait, options) {
            let timeout, context, args, result
            let previous = 0
            if (!options) options = {}

            const later = function () {
              previous = options.leading === false ? 0 : _.now()
              timeout = null
              result = func.apply(context, args)
              if (!timeout) context = args = null
            }

            const throttled = function () {
              const now = _.now()
              if (!previous && options.leading === false) previous = now
              const remaining = wait - (now - previous)
              context = this
              args = arguments
              if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                  clearTimeout(timeout)
                  timeout = null
                }
                previous = now
                result = func.apply(context, args)
                if (!timeout) context = args = null
              } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining)
              }
              return result
            }

            throttled.cancel = function () {
              clearTimeout(timeout)
              previous = 0
              timeout = context = args = null
            }

            return throttled
          }

          // Returns a function, that, as long as it continues to be invoked, will not
          // be triggered. The function will be called after it stops being called for
          // N milliseconds. If `immediate` is passed, trigger the function on the
          // leading edge, instead of the trailing.
          _.debounce = function (func, wait, immediate) {
            let timeout, result

            const later = function (context, args) {
              timeout = null
              if (args) result = func.apply(context, args)
            }

            const debounced = restArguments(function (args) {
              if (timeout) clearTimeout(timeout)
              if (immediate) {
                const callNow = !timeout
                timeout = setTimeout(later, wait)
                if (callNow) result = func.apply(this, args)
              } else {
                timeout = _.delay(later, wait, this, args)
              }

              return result
            })

            debounced.cancel = function () {
              clearTimeout(timeout)
              timeout = null
            }

            return debounced
          }

          // Returns the first function passed as an argument to the second,
          // allowing you to adjust arguments, run code before and after, and
          // conditionally execute the original function.
          _.wrap = function (func, wrapper) {
            return _.partial(wrapper, func)
          }

          // Returns a negated version of the passed-in predicate.
          _.negate = function (predicate) {
            return function () {
              return !predicate.apply(this, arguments)
            }
          }

          // Returns a function that is the composition of a list of functions, each
          // consuming the return value of the function that follows.
          _.compose = function () {
            const args = arguments
            const start = args.length - 1
            return function () {
              let i = start
              let result = args[start].apply(this, arguments)
              while (i--) result = args[i].call(this, result)
              return result
            }
          }

          // Returns a function that will only be executed on and after the Nth call.
          _.after = function (times, func) {
            return function () {
              if (--times < 1) {
                return func.apply(this, arguments)
              }
            }
          }

          // Returns a function that will only be executed up to (but not including) the Nth call.
          _.before = function (times, func) {
            let memo
            return function () {
              if (--times > 0) {
                memo = func.apply(this, arguments)
              }
              if (times <= 1) func = null
              return memo
            }
          }

          // Returns a function that will be executed at most one time, no matter how
          // often you call it. Useful for lazy initialization.
          _.once = _.partial(_.before, 2)

          _.restArguments = restArguments

          // Object Functions
          // ----------------

          // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
          const hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString')
          const nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
            'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']

          const collectNonEnumProps = function (obj, keys) {
            let nonEnumIdx = nonEnumerableProps.length
            const constructor = obj.constructor
            const proto = _.isFunction(constructor) && constructor.prototype || ObjProto

            // Constructor is a special case.
            let prop = 'constructor'
            if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop)

            while (nonEnumIdx--) {
              prop = nonEnumerableProps[nonEnumIdx]
              if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
                keys.push(prop)
              }
            }
          }

          // Retrieve the names of an object's own properties.
          // Delegates to **ECMAScript 5**'s native `Object.keys`.
          _.keys = function (obj) {
            if (!_.isObject(obj)) return []
            if (nativeKeys) return nativeKeys(obj)
            const keys = []
            for (const key in obj) if (has(obj, key)) keys.push(key)
            // Ahem, IE < 9.
            if (hasEnumBug) collectNonEnumProps(obj, keys)
            return keys
          }

          // Retrieve all the property names of an object.
          _.allKeys = function (obj) {
            if (!_.isObject(obj)) return []
            const keys = []
            for (const key in obj) keys.push(key)
            // Ahem, IE < 9.
            if (hasEnumBug) collectNonEnumProps(obj, keys)
            return keys
          }

          // Retrieve the values of an object's properties.
          _.values = function (obj) {
            const keys = _.keys(obj)
            const length = keys.length
            const values = Array(length)
            for (let i = 0; i < length; i++) {
              values[i] = obj[keys[i]]
            }
            return values
          }

          // Returns the results of applying the iteratee to each element of the object.
          // In contrast to _.map it returns an object.
          _.mapObject = function (obj, iteratee, context) {
            iteratee = cb(iteratee, context)
            const keys = _.keys(obj)
            const length = keys.length
            const results = {}
            for (let index = 0; index < length; index++) {
              const currentKey = keys[index]
              results[currentKey] = iteratee(obj[currentKey], currentKey, obj)
            }
            return results
          }

          // Convert an object into a list of `[key, value]` pairs.
          // The opposite of _.object.
          _.pairs = function (obj) {
            const keys = _.keys(obj)
            const length = keys.length
            const pairs = Array(length)
            for (let i = 0; i < length; i++) {
              pairs[i] = [keys[i], obj[keys[i]]]
            }
            return pairs
          }

          // Invert the keys and values of an object. The values must be serializable.
          _.invert = function (obj) {
            const result = {}
            const keys = _.keys(obj)
            for (let i = 0, length = keys.length; i < length; i++) {
              result[obj[keys[i]]] = keys[i]
            }
            return result
          }

          // Return a sorted list of the function names available on the object.
          // Aliased as `methods`.
          _.functions = _.methods = function (obj) {
            const names = []
            for (const key in obj) {
              if (_.isFunction(obj[key])) names.push(key)
            }
            return names.sort()
          }

          // An internal function for creating assigner functions.
          const createAssigner = function (keysFunc, defaults) {
            return function (obj) {
              const length = arguments.length
              if (defaults) obj = Object(obj)
              if (length < 2 || obj == null) return obj
              for (let index = 1; index < length; index++) {
                const source = arguments[index]
                const keys = keysFunc(source)
                const l = keys.length
                for (let i = 0; i < l; i++) {
                  const key = keys[i]
                  if (!defaults || obj[key] === void 0) obj[key] = source[key]
                }
              }
              return obj
            }
          }

          // Extend a given object with all the properties in passed-in object(s).
          _.extend = createAssigner(_.allKeys)

          // Assigns a given object with all the own properties in the passed-in object(s).
          // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
          _.extendOwn = _.assign = createAssigner(_.keys)

          // Returns the first key on an object that passes a predicate test.
          _.findKey = function (obj, predicate, context) {
            predicate = cb(predicate, context)
            const keys = _.keys(obj); let key
            for (let i = 0, length = keys.length; i < length; i++) {
              key = keys[i]
              if (predicate(obj[key], key, obj)) return key
            }
          }

          // Internal pick helper function to determine if `obj` has key `key`.
          const keyInObj = function (value, key, obj) {
            return key in obj
          }

          // Return a copy of the object only containing the whitelisted properties.
          _.pick = restArguments(function (obj, keys) {
            const result = {}; let iteratee = keys[0]
            if (obj == null) return result
            if (_.isFunction(iteratee)) {
              if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1])
              keys = _.allKeys(obj)
            } else {
              iteratee = keyInObj
              keys = flatten(keys, false, false)
              obj = Object(obj)
            }
            for (let i = 0, length = keys.length; i < length; i++) {
              const key = keys[i]
              const value = obj[key]
              if (iteratee(value, key, obj)) result[key] = value
            }
            return result
          })

          // Return a copy of the object without the blacklisted properties.
          _.omit = restArguments(function (obj, keys) {
            let iteratee = keys[0]; let context
            if (_.isFunction(iteratee)) {
              iteratee = _.negate(iteratee)
              if (keys.length > 1) context = keys[1]
            } else {
              keys = _.map(flatten(keys, false, false), String)
              iteratee = function (value, key) {
                return !_.contains(keys, key)
              }
            }
            return _.pick(obj, iteratee, context)
          })

          // Fill in a given object with default properties.
          _.defaults = createAssigner(_.allKeys, true)

          // Creates an object that inherits from the given prototype object.
          // If additional properties are provided then they will be added to the
          // created object.
          _.create = function (prototype, props) {
            const result = baseCreate(prototype)
            if (props) _.extendOwn(result, props)
            return result
          }

          // Create a (shallow-cloned) duplicate of an object.
          _.clone = function (obj) {
            if (!_.isObject(obj)) return obj
            return _.isArray(obj) ? obj.slice() : _.extend({}, obj)
          }

          // Invokes interceptor with the obj, and then returns obj.
          // The primary purpose of this method is to "tap into" a method chain, in
          // order to perform operations on intermediate results within the chain.
          _.tap = function (obj, interceptor) {
            interceptor(obj)
            return obj
          }

          // Returns whether an object has a given set of `key:value` pairs.
          _.isMatch = function (object, attrs) {
            const keys = _.keys(attrs); const length = keys.length
            if (object == null) return !length
            const obj = Object(object)
            for (let i = 0; i < length; i++) {
              const key = keys[i]
              if (attrs[key] !== obj[key] || !(key in obj)) return false
            }
            return true
          }

          // Internal recursive comparison function for `isEqual`.
          let eq, deepEq
          eq = function (a, b, aStack, bStack) {
            // Identical objects are equal. `0 === -0`, but they aren't identical.
            // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
            if (a === b) return a !== 0 || 1 / a === 1 / b
            // `null` or `undefined` only equal to itself (strict comparison).
            if (a == null || b == null) return false
            // `NaN`s are equivalent, but non-reflexive.
            if (a !== a) return b !== b
            // Exhaust primitive checks
            const type = typeof a
            if (type !== 'function' && type !== 'object' && typeof b !== 'object') return false
            return deepEq(a, b, aStack, bStack)
          }

          // Internal recursive comparison function for `isEqual`.
          deepEq = function (a, b, aStack, bStack) {
            // Unwrap any wrapped objects.
            if (a instanceof _) a = a._wrapped
            if (b instanceof _) b = b._wrapped
            // Compare `[[Class]]` names.
            const className = toString.call(a)
            if (className !== toString.call(b)) return false
            switch (className) {
              // Strings, numbers, regular expressions, dates, and booleans are compared by value.
              case '[object RegExp]':
                // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
              case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return '' + a === '' + b
              case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive.
                // Object(NaN) is equivalent to NaN.
                if (+a !== +a) return +b !== +b
                // An `egal` comparison is performed for other numeric values.
                return +a === 0 ? 1 / +a === 1 / b : +a === +b
              case '[object Date]':
              case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a === +b
              case '[object Symbol]':
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b)
            }

            const areArrays = className === '[object Array]'
            if (!areArrays) {
              if (typeof a !== 'object' || typeof b !== 'object') return false

              // Objects with different constructors are not equivalent, but `Object`s or `Array`s
              // from different frames are.
              const aCtor = a.constructor; const bCtor = b.constructor
              if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor) &&
                          ('constructor' in a && 'constructor' in b)) {
                return false
              }
            }
            // Assume equality for cyclic structures. The algorithm for detecting cyclic
            // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

            // Initializing stack of traversed objects.
            // It's done here since we only need them for objects and arrays comparison.
            aStack = aStack || []
            bStack = bStack || []
            let length = aStack.length
            while (length--) {
              // Linear search. Performance is inversely proportional to the number of
              // unique nested structures.
              if (aStack[length] === a) return bStack[length] === b
            }

            // Add the first object to the stack of traversed objects.
            aStack.push(a)
            bStack.push(b)

            // Recursively compare objects and arrays.
            if (areArrays) {
              // Compare array lengths to determine if a deep comparison is necessary.
              length = a.length
              if (length !== b.length) return false
              // Deep compare the contents, ignoring non-numeric properties.
              while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false
              }
            } else {
              // Deep compare objects.
              const keys = _.keys(a); let key
              length = keys.length
              // Ensure that both objects contain the same number of properties before comparing deep equality.
              if (_.keys(b).length !== length) return false
              while (length--) {
                // Deep compare each member
                key = keys[length]
                if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false
              }
            }
            // Remove the first object from the stack of traversed objects.
            aStack.pop()
            bStack.pop()
            return true
          }

          // Perform a deep comparison to check if two objects are equal.
          _.isEqual = function (a, b) {
            return eq(a, b)
          }

          // Is a given array, string, or object empty?
          // An "empty" object has no enumerable own-properties.
          _.isEmpty = function (obj) {
            if (obj == null) return true
            if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0
            return _.keys(obj).length === 0
          }

          // Is a given value a DOM element?
          _.isElement = function (obj) {
            return !!(obj && obj.nodeType === 1)
          }

          // Is a given value an array?
          // Delegates to ECMA5's native Array.isArray
          _.isArray = nativeIsArray || function (obj) {
            return toString.call(obj) === '[object Array]'
          }

          // Is a given variable an object?
          _.isObject = function (obj) {
            const type = typeof obj
            return type === 'function' || type === 'object' && !!obj
          }

          // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
          _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
            _['is' + name] = function (obj) {
              return toString.call(obj) === '[object ' + name + ']'
            }
          })

          // Define a fallback version of the method in browsers (ahem, IE < 9), where
          // there isn't any inspectable "Arguments" type.
          if (!_.isArguments(arguments)) {
            _.isArguments = function (obj) {
              return has(obj, 'callee')
            }
          }

          // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
          // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
          const nodelist = root.document && root.document.childNodes
          if (typeof /./ !== 'function' && typeof Int8Array !== 'object' && typeof nodelist !== 'function') {
            _.isFunction = function (obj) {
              return typeof obj === 'function' || false
            }
          }

          // Is a given object a finite number?
          _.isFinite = function (obj) {
            return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj))
          }

          // Is the given value `NaN`?
          _.isNaN = function (obj) {
            return _.isNumber(obj) && isNaN(obj)
          }

          // Is a given value a boolean?
          _.isBoolean = function (obj) {
            return obj === true || obj === false || toString.call(obj) === '[object Boolean]'
          }

          // Is a given value equal to null?
          _.isNull = function (obj) {
            return obj === null
          }

          // Is a given variable undefined?
          _.isUndefined = function (obj) {
            return obj === void 0
          }

          // Shortcut function for checking if an object has a given property directly
          // on itself (in other words, not on a prototype).
          _.has = function (obj, path) {
            if (!_.isArray(path)) {
              return has(obj, path)
            }
            const length = path.length
            for (let i = 0; i < length; i++) {
              const key = path[i]
              if (obj == null || !hasOwnProperty.call(obj, key)) {
                return false
              }
              obj = obj[key]
            }
            return !!length
          }

          // Utility Functions
          // -----------------

          // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
          // previous owner. Returns a reference to the Underscore object.
          _.noConflict = function () {
            root._ = previousUnderscore
            return this
          }

          // Keep the identity function around for default iteratees.
          _.identity = function (value) {
            return value
          }

          // Predicate-generating functions. Often useful outside of Underscore.
          _.constant = function (value) {
            return function () {
              return value
            }
          }

          _.noop = function () {}

          // Creates a function that, when passed an object, will traverse that object’s
          // properties down the given `path`, specified as an array of keys or indexes.
          _.property = function (path) {
            if (!_.isArray(path)) {
              return shallowProperty(path)
            }
            return function (obj) {
              return deepGet(obj, path)
            }
          }

          // Generates a function for a given object that returns a given property.
          _.propertyOf = function (obj) {
            if (obj == null) {
              return function () {}
            }
            return function (path) {
              return !_.isArray(path) ? obj[path] : deepGet(obj, path)
            }
          }

          // Returns a predicate for checking whether an object has a given set of
          // `key:value` pairs.
          _.matcher = _.matches = function (attrs) {
            attrs = _.extendOwn({}, attrs)
            return function (obj) {
              return _.isMatch(obj, attrs)
            }
          }

          // Run a function **n** times.
          _.times = function (n, iteratee, context) {
            const accum = Array(Math.max(0, n))
            iteratee = optimizeCb(iteratee, context, 1)
            for (let i = 0; i < n; i++) accum[i] = iteratee(i)
            return accum
          }

          // Return a random integer between min and max (inclusive).
          _.random = function (min, max) {
            if (max == null) {
              max = min
              min = 0
            }
            return min + Math.floor(Math.random() * (max - min + 1))
          }

          // A (possibly faster) way to get the current timestamp as an integer.
          _.now = Date.now || function () {
            return new Date().getTime()
          }

          // List of HTML entities for escaping.
          const escapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '`': '&#x60;'
          }
          const unescapeMap = _.invert(escapeMap)

          // Functions for escaping and unescaping strings to/from HTML interpolation.
          const createEscaper = function (map) {
            const escaper = function (match) {
              return map[match]
            }
            // Regexes for identifying a key that needs to be escaped.
            const source = '(?:' + _.keys(map).join('|') + ')'
            const testRegexp = RegExp(source)
            const replaceRegexp = RegExp(source, 'g')
            return function (string) {
              string = string == null ? '' : '' + string
              return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string
            }
          }
          _.escape = createEscaper(escapeMap)
          _.unescape = createEscaper(unescapeMap)

          // Traverses the children of `obj` along `path`. If a child is a function, it
          // is invoked with its parent as context. Returns the value of the final
          // child, or `fallback` if any child is undefined.
          _.result = function (obj, path, fallback) {
            if (!_.isArray(path)) path = [path]
            const length = path.length
            if (!length) {
              return _.isFunction(fallback) ? fallback.call(obj) : fallback
            }
            for (let i = 0; i < length; i++) {
              let prop = obj == null ? void 0 : obj[path[i]]
              if (prop === void 0) {
                prop = fallback
                i = length // Ensure we don't continue iterating.
              }
              obj = _.isFunction(prop) ? prop.call(obj) : prop
            }
            return obj
          }

          // Generate a unique integer id (unique within the entire client session).
          // Useful for temporary DOM ids.
          let idCounter = 0
          _.uniqueId = function (prefix) {
            const id = ++idCounter + ''
            return prefix ? prefix + id : id
          }

          // By default, Underscore uses ERB-style template delimiters, change the
          // following template settings to use alternative delimiters.
          _.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
          }

          // When customizing `templateSettings`, if you don't want to define an
          // interpolation, evaluation or escaping regex, we need one that is
          // guaranteed not to match.
          const noMatch = /(.)^/

          // Certain characters need to be escaped so that they can be put into a
          // string literal.
          const escapes = {
            "'": "'",
            '\\': '\\',
            '\r': 'r',
            '\n': 'n',
            '\u2028': 'u2028',
            '\u2029': 'u2029'
          }

          const escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g

          const escapeChar = function (match) {
            return '\\' + escapes[match]
          }

          // JavaScript micro-templating, similar to John Resig's implementation.
          // Underscore templating handles arbitrary delimiters, preserves whitespace,
          // and correctly escapes quotes within interpolated code.
          // NB: `oldSettings` only exists for backwards compatibility.
          _.template = function (text, settings, oldSettings) {
            if (!settings && oldSettings) settings = oldSettings
            settings = _.defaults({}, settings, _.templateSettings)

            // Combine delimiters into one regular expression via alternation.
            const matcher = RegExp([
              (settings.escape || noMatch).source,
              (settings.interpolate || noMatch).source,
              (settings.evaluate || noMatch).source
            ].join('|') + '|$', 'g')

            // Compile the template source, escaping string literals appropriately.
            let index = 0
            let source = "__p+='"
            text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
              source += text.slice(index, offset).replace(escapeRegExp, escapeChar)
              index = offset + match.length

              if (escape) {
                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'"
              } else if (interpolate) {
                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'"
              } else if (evaluate) {
                source += "';\n" + evaluate + "\n__p+='"
              }

              // Adobe VMs need the match returned to produce the correct offset.
              return match
            })
            source += "';\n"

            // If a variable is not specified, place data values in local scope.
            if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n'

            source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n'

            let render
            try {
              render = new Function(settings.variable || 'obj', '_', source)
            } catch (e) {
              e.source = source
              throw e
            }

            const template = function (data) {
              return render.call(this, data, _)
            }

            // Provide the compiled source as a convenience for precompilation.
            const argument = settings.variable || 'obj'
            template.source = 'function(' + argument + '){\n' + source + '}'

            return template
          }

          // Add a "chain" function. Start chaining a wrapped Underscore object.
          _.chain = function (obj) {
            const instance = _(obj)
            instance._chain = true
            return instance
          }

          // OOP
          // ---------------
          // If Underscore is called as a function, it returns a wrapped object that
          // can be used OO-style. This wrapper holds altered versions of all the
          // underscore functions. Wrapped objects may be chained.

          // Helper function to continue chaining intermediate results.
          const chainResult = function (instance, obj) {
            return instance._chain ? _(obj).chain() : obj
          }

          // Add your own custom functions to the Underscore object.
          _.mixin = function (obj) {
            _.each(_.functions(obj), function (name) {
              const func = _[name] = obj[name]
              _.prototype[name] = function () {
                const args = [this._wrapped]
                push.apply(args, arguments)
                return chainResult(this, func.apply(_, args))
              }
            })
            return _
          }

          // Add all of the Underscore functions to the wrapper object.
          _.mixin(_)

          // Add all mutator Array functions to the wrapper.
          _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
            const method = ArrayProto[name]
            _.prototype[name] = function () {
              const obj = this._wrapped
              method.apply(obj, arguments)
              if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0]
              return chainResult(this, obj)
            }
          })

          // Add all accessor Array functions to the wrapper.
          _.each(['concat', 'join', 'slice'], function (name) {
            const method = ArrayProto[name]
            _.prototype[name] = function () {
              return chainResult(this, method.apply(this._wrapped, arguments))
            }
          })

          // Extracts the result from a wrapped and chained object.
          _.prototype.value = function () {
            return this._wrapped
          }

          // Provide unwrapping proxy for some methods used in engine operations
          // such as arithmetic and JSON stringification.
          _.prototype.valueOf = _.prototype.toJSON = _.prototype.value

          _.prototype.toString = function () {
            return String(this._wrapped)
          }

          // AMD registration happens at the end for compatibility with AMD loaders
          // that may not enforce next-turn semantics on modules. Even though general
          // practice for AMD registration is to be anonymous, underscore registers
          // as a named module because, like jQuery, it is a base library that is
          // popular enough to be bundled in a third party lib, but not be part of
          // an AMD load request. Those cases could generate an error when an
          // anonymous define() is called outside of a loader request.
          if (typeof define === 'function' && define.amd) {
            define('underscore', [], function () {
              return _
            })
          }
        }())
      }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
    }, {}],
    5: [function (require, module, exports) {
      exports = module.exports = Victor

      /**
 * # Victor - A JavaScript 2D vector class with methods for common vector operations
 */

      /**
 * Constructor. Will also work without the `new` keyword
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = Victor(42, 1337);
 *
 * @param {Number} x Value of the x axis
 * @param {Number} y Value of the y axis
 * @return {Victor}
 * @api public
 */
      function Victor (x, y) {
        if (!(this instanceof Victor)) {
          return new Victor(x, y)
        }

        /**
	 * The X axis
	 *
	 * ### Examples:
	 *     var vec = new Victor.fromArray(42, 21);
	 *
	 *     vec.x;
	 *     // => 42
	 *
	 * @api public
	 */
        this.x = x || 0

        /**
	 * The Y axis
	 *
	 * ### Examples:
	 *     var vec = new Victor.fromArray(42, 21);
	 *
	 *     vec.y;
	 *     // => 21
	 *
	 * @api public
	 */
        this.y = y || 0
      };

      /**
 * # Static
 */

      /**
 * Creates a new instance from an array
 *
 * ### Examples:
 *     var vec = Victor.fromArray([42, 21]);
 *
 *     vec.toString();
 *     // => x:42, y:21
 *
 * @name Victor.fromArray
 * @param {Array} array Array with the x and y values at index 0 and 1 respectively
 * @return {Victor} The new instance
 * @api public
 */
      Victor.fromArray = function (arr) {
        return new Victor(arr[0] || 0, arr[1] || 0)
      }

      /**
 * Creates a new instance from an object
 *
 * ### Examples:
 *     var vec = Victor.fromObject({ x: 42, y: 21 });
 *
 *     vec.toString();
 *     // => x:42, y:21
 *
 * @name Victor.fromObject
 * @param {Object} obj Object with the values for x and y
 * @return {Victor} The new instance
 * @api public
 */
      Victor.fromObject = function (obj) {
        return new Victor(obj.x || 0, obj.y || 0)
      }

      /**
 * # Manipulation
 *
 * These functions are chainable.
 */

      /**
 * Adds another vector's X axis to this one
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.addX(vec2);
 *     vec1.toString();
 *     // => x:30, y:10
 *
 * @param {Victor} vector The other vector you want to add to this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.addX = function (vec) {
        this.x += vec.x
        return this
      }

      /**
 * Adds another vector's Y axis to this one
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.addY(vec2);
 *     vec1.toString();
 *     // => x:10, y:40
 *
 * @param {Victor} vector The other vector you want to add to this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.addY = function (vec) {
        this.y += vec.y
        return this
      }

      /**
 * Adds another vector to this one
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.add(vec2);
 *     vec1.toString();
 *     // => x:30, y:40
 *
 * @param {Victor} vector The other vector you want to add to this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.add = function (vec) {
        this.x += vec.x
        this.y += vec.y
        return this
      }

      /**
 * Adds the given scalar to both vector axis
 *
 * ### Examples:
 *     var vec = new Victor(1, 2);
 *
 *     vec.addScalar(2);
 *     vec.toString();
 *     // => x: 3, y: 4
 *
 * @param {Number} scalar The scalar to add
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.addScalar = function (scalar) {
        this.x += scalar
        this.y += scalar
        return this
      }

      /**
 * Adds the given scalar to the X axis
 *
 * ### Examples:
 *     var vec = new Victor(1, 2);
 *
 *     vec.addScalarX(2);
 *     vec.toString();
 *     // => x: 3, y: 2
 *
 * @param {Number} scalar The scalar to add
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.addScalarX = function (scalar) {
        this.x += scalar
        return this
      }

      /**
 * Adds the given scalar to the Y axis
 *
 * ### Examples:
 *     var vec = new Victor(1, 2);
 *
 *     vec.addScalarY(2);
 *     vec.toString();
 *     // => x: 1, y: 4
 *
 * @param {Number} scalar The scalar to add
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.addScalarY = function (scalar) {
        this.y += scalar
        return this
      }

      /**
 * Subtracts the X axis of another vector from this one
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.subtractX(vec2);
 *     vec1.toString();
 *     // => x:80, y:50
 *
 * @param {Victor} vector The other vector you want subtract from this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.subtractX = function (vec) {
        this.x -= vec.x
        return this
      }

      /**
 * Subtracts the Y axis of another vector from this one
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.subtractY(vec2);
 *     vec1.toString();
 *     // => x:100, y:20
 *
 * @param {Victor} vector The other vector you want subtract from this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.subtractY = function (vec) {
        this.y -= vec.y
        return this
      }

      /**
 * Subtracts another vector from this one
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(20, 30);
 *
 *     vec1.subtract(vec2);
 *     vec1.toString();
 *     // => x:80, y:20
 *
 * @param {Victor} vector The other vector you want subtract from this one
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.subtract = function (vec) {
        this.x -= vec.x
        this.y -= vec.y
        return this
      }

      /**
 * Subtracts the given scalar from both axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 200);
 *
 *     vec.subtractScalar(20);
 *     vec.toString();
 *     // => x: 80, y: 180
 *
 * @param {Number} scalar The scalar to subtract
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.subtractScalar = function (scalar) {
        this.x -= scalar
        this.y -= scalar
        return this
      }

      /**
 * Subtracts the given scalar from the X axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 200);
 *
 *     vec.subtractScalarX(20);
 *     vec.toString();
 *     // => x: 80, y: 200
 *
 * @param {Number} scalar The scalar to subtract
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.subtractScalarX = function (scalar) {
        this.x -= scalar
        return this
      }

      /**
 * Subtracts the given scalar from the Y axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 200);
 *
 *     vec.subtractScalarY(20);
 *     vec.toString();
 *     // => x: 100, y: 180
 *
 * @param {Number} scalar The scalar to subtract
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.subtractScalarY = function (scalar) {
        this.y -= scalar
        return this
      }

      /**
 * Divides the X axis by the x component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 0);
 *
 *     vec.divideX(vec2);
 *     vec.toString();
 *     // => x:50, y:50
 *
 * @param {Victor} vector The other vector you want divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.divideX = function (vector) {
        this.x /= vector.x
        return this
      }

      /**
 * Divides the Y axis by the y component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(0, 2);
 *
 *     vec.divideY(vec2);
 *     vec.toString();
 *     // => x:100, y:25
 *
 * @param {Victor} vector The other vector you want divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.divideY = function (vector) {
        this.y /= vector.y
        return this
      }

      /**
 * Divides both vector axis by a axis values of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 2);
 *
 *     vec.divide(vec2);
 *     vec.toString();
 *     // => x:50, y:25
 *
 * @param {Victor} vector The vector to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.divide = function (vector) {
        this.x /= vector.x
        this.y /= vector.y
        return this
      }

      /**
 * Divides both vector axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.divideScalar(2);
 *     vec.toString();
 *     // => x:50, y:25
 *
 * @param {Number} The scalar to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.divideScalar = function (scalar) {
        if (scalar !== 0) {
          this.x /= scalar
          this.y /= scalar
        } else {
          this.x = 0
          this.y = 0
        }

        return this
      }

      /**
 * Divides the X axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.divideScalarX(2);
 *     vec.toString();
 *     // => x:50, y:50
 *
 * @param {Number} The scalar to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.divideScalarX = function (scalar) {
        if (scalar !== 0) {
          this.x /= scalar
        } else {
          this.x = 0
        }
        return this
      }

      /**
 * Divides the Y axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.divideScalarY(2);
 *     vec.toString();
 *     // => x:100, y:25
 *
 * @param {Number} The scalar to divide by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.divideScalarY = function (scalar) {
        if (scalar !== 0) {
          this.y /= scalar
        } else {
          this.y = 0
        }
        return this
      }

      /**
 * Inverts the X axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.invertX();
 *     vec.toString();
 *     // => x:-100, y:50
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.invertX = function () {
        this.x *= -1
        return this
      }

      /**
 * Inverts the Y axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.invertY();
 *     vec.toString();
 *     // => x:100, y:-50
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.invertY = function () {
        this.y *= -1
        return this
      }

      /**
 * Inverts both axis
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.invert();
 *     vec.toString();
 *     // => x:-100, y:-50
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.invert = function () {
        this.invertX()
        this.invertY()
        return this
      }

      /**
 * Multiplies the X axis by X component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 0);
 *
 *     vec.multiplyX(vec2);
 *     vec.toString();
 *     // => x:200, y:50
 *
 * @param {Victor} vector The vector to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.multiplyX = function (vector) {
        this.x *= vector.x
        return this
      }

      /**
 * Multiplies the Y axis by Y component of given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(0, 2);
 *
 *     vec.multiplyX(vec2);
 *     vec.toString();
 *     // => x:100, y:100
 *
 * @param {Victor} vector The vector to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.multiplyY = function (vector) {
        this.y *= vector.y
        return this
      }

      /**
 * Multiplies both vector axis by values from a given vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     var vec2 = new Victor(2, 2);
 *
 *     vec.multiply(vec2);
 *     vec.toString();
 *     // => x:200, y:100
 *
 * @param {Victor} vector The vector to multiply by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.multiply = function (vector) {
        this.x *= vector.x
        this.y *= vector.y
        return this
      }

      /**
 * Multiplies both vector axis by the given scalar value
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.multiplyScalar(2);
 *     vec.toString();
 *     // => x:200, y:100
 *
 * @param {Number} The scalar to multiply by
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.multiplyScalar = function (scalar) {
        this.x *= scalar
        this.y *= scalar
        return this
      }

      /**
 * Multiplies the X axis by the given scalar
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.multiplyScalarX(2);
 *     vec.toString();
 *     // => x:200, y:50
 *
 * @param {Number} The scalar to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.multiplyScalarX = function (scalar) {
        this.x *= scalar
        return this
      }

      /**
 * Multiplies the Y axis by the given scalar
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.multiplyScalarY(2);
 *     vec.toString();
 *     // => x:100, y:100
 *
 * @param {Number} The scalar to multiply the axis with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.multiplyScalarY = function (scalar) {
        this.y *= scalar
        return this
      }

      /**
 * Normalize
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.normalize = function () {
        const length = this.length()

        if (length === 0) {
          this.x = 1
          this.y = 0
        } else {
          this.divide(Victor(length, length))
        }
        return this
      }

      Victor.prototype.norm = Victor.prototype.normalize

      /**
 * If the absolute vector axis is greater than `max`, multiplies the axis by `factor`
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.limit(80, 0.9);
 *     vec.toString();
 *     // => x:90, y:50
 *
 * @param {Number} max The maximum value for both x and y axis
 * @param {Number} factor Factor by which the axis are to be multiplied with
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.limit = function (max, factor) {
        if (Math.abs(this.x) > max) { this.x *= factor }
        if (Math.abs(this.y) > max) { this.y *= factor }
        return this
      }

      /**
 * Randomizes both vector axis with a value between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomize(new Victor(50, 60), new Victor(70, 80`));
 *     vec.toString();
 *     // => x:67, y:73
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.randomize = function (topLeft, bottomRight) {
        this.randomizeX(topLeft, bottomRight)
        this.randomizeY(topLeft, bottomRight)

        return this
      }

      /**
 * Randomizes the y axis with a value between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomizeX(new Victor(50, 60), new Victor(70, 80`));
 *     vec.toString();
 *     // => x:55, y:50
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.randomizeX = function (topLeft, bottomRight) {
        const min = Math.min(topLeft.x, bottomRight.x)
        const max = Math.max(topLeft.x, bottomRight.x)
        this.x = random(min, max)
        return this
      }

      /**
 * Randomizes the y axis with a value between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomizeY(new Victor(50, 60), new Victor(70, 80`));
 *     vec.toString();
 *     // => x:100, y:66
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.randomizeY = function (topLeft, bottomRight) {
        const min = Math.min(topLeft.y, bottomRight.y)
        const max = Math.max(topLeft.y, bottomRight.y)
        this.y = random(min, max)
        return this
      }

      /**
 * Randomly randomizes either axis between 2 vectors
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.randomizeAny(new Victor(50, 60), new Victor(70, 80));
 *     vec.toString();
 *     // => x:100, y:77
 *
 * @param {Victor} topLeft first vector
 * @param {Victor} bottomRight second vector
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.randomizeAny = function (topLeft, bottomRight) {
        if (Math.round(Math.random())) {
          this.randomizeX(topLeft, bottomRight)
        } else {
          this.randomizeY(topLeft, bottomRight)
        }
        return this
      }

      /**
 * Rounds both axis to an integer value
 *
 * ### Examples:
 *     var vec = new Victor(100.2, 50.9);
 *
 *     vec.unfloat();
 *     vec.toString();
 *     // => x:100, y:51
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.unfloat = function () {
        this.x = Math.round(this.x)
        this.y = Math.round(this.y)
        return this
      }

      /**
 * Rounds both axis to a certain precision
 *
 * ### Examples:
 *     var vec = new Victor(100.2, 50.9);
 *
 *     vec.unfloat();
 *     vec.toString();
 *     // => x:100, y:51
 *
 * @param {Number} Precision (default: 8)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.toFixed = function (precision) {
        if (typeof precision === 'undefined') { precision = 8 }
        this.x = this.x.toFixed(precision)
        this.y = this.y.toFixed(precision)
        return this
      }

      /**
 * Performs a linear blend / interpolation of the X axis towards another vector
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 100);
 *     var vec2 = new Victor(200, 200);
 *
 *     vec1.mixX(vec2, 0.5);
 *     vec.toString();
 *     // => x:150, y:100
 *
 * @param {Victor} vector The other vector
 * @param {Number} amount The blend amount (optional, default: 0.5)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.mixX = function (vec, amount) {
        if (typeof amount === 'undefined') {
          amount = 0.5
        }

        this.x = (1 - amount) * this.x + amount * vec.x
        return this
      }

      /**
 * Performs a linear blend / interpolation of the Y axis towards another vector
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 100);
 *     var vec2 = new Victor(200, 200);
 *
 *     vec1.mixY(vec2, 0.5);
 *     vec.toString();
 *     // => x:100, y:150
 *
 * @param {Victor} vector The other vector
 * @param {Number} amount The blend amount (optional, default: 0.5)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.mixY = function (vec, amount) {
        if (typeof amount === 'undefined') {
          amount = 0.5
        }

        this.y = (1 - amount) * this.y + amount * vec.y
        return this
      }

      /**
 * Performs a linear blend / interpolation towards another vector
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 100);
 *     var vec2 = new Victor(200, 200);
 *
 *     vec1.mix(vec2, 0.5);
 *     vec.toString();
 *     // => x:150, y:150
 *
 * @param {Victor} vector The other vector
 * @param {Number} amount The blend amount (optional, default: 0.5)
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.mix = function (vec, amount) {
        this.mixX(vec, amount)
        this.mixY(vec, amount)
        return this
      }

      /**
 * # Products
 */

      /**
 * Creates a clone of this vector
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = vec1.clone();
 *
 *     vec2.toString();
 *     // => x:10, y:10
 *
 * @return {Victor} A clone of the vector
 * @api public
 */
      Victor.prototype.clone = function () {
        return new Victor(this.x, this.y)
      }

      /**
 * Copies another vector's X component in to its own
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 20);
 *     var vec2 = vec1.copyX(vec1);
 *
 *     vec2.toString();
 *     // => x:20, y:10
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.copyX = function (vec) {
        this.x = vec.x
        return this
      }

      /**
 * Copies another vector's Y component in to its own
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 20);
 *     var vec2 = vec1.copyY(vec1);
 *
 *     vec2.toString();
 *     // => x:10, y:20
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.copyY = function (vec) {
        this.y = vec.y
        return this
      }

      /**
 * Copies another vector's X and Y components in to its own
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *     var vec2 = new Victor(20, 20);
 *     var vec2 = vec1.copy(vec1);
 *
 *     vec2.toString();
 *     // => x:20, y:20
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.copy = function (vec) {
        this.copyX(vec)
        this.copyY(vec)
        return this
      }

      /**
 * Sets the vector to zero (0,0)
 *
 * ### Examples:
 *     var vec1 = new Victor(10, 10);
 *		 var1.zero();
 *     vec1.toString();
 *     // => x:0, y:0
 *
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.zero = function () {
        this.x = this.y = 0
        return this
      }

      /**
 * Calculates the dot product of this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.dot(vec2);
 *     // => 23000
 *
 * @param {Victor} vector The second vector
 * @return {Number} Dot product
 * @api public
 */
      Victor.prototype.dot = function (vec2) {
        return this.x * vec2.x + this.y * vec2.y
      }

      Victor.prototype.cross = function (vec2) {
        return (this.x * vec2.y) - (this.y * vec2.x)
      }

      /**
 * Projects a vector onto another vector, setting itself to the result.
 *
 * ### Examples:
 *     var vec = new Victor(100, 0);
 *     var vec2 = new Victor(100, 100);
 *
 *     vec.projectOnto(vec2);
 *     vec.toString();
 *     // => x:50, y:50
 *
 * @param {Victor} vector The other vector you want to project this vector onto
 * @return {Victor} `this` for chaining capabilities
 * @api public
 */
      Victor.prototype.projectOnto = function (vec2) {
        const coeff = ((this.x * vec2.x) + (this.y * vec2.y)) / ((vec2.x * vec2.x) + (vec2.y * vec2.y))
        this.x = coeff * vec2.x
        this.y = coeff * vec2.y
        return this
      }

      Victor.prototype.horizontalAngle = function () {
        return Math.atan2(this.y, this.x)
      }

      Victor.prototype.horizontalAngleDeg = function () {
        return radian2degrees(this.horizontalAngle())
      }

      Victor.prototype.verticalAngle = function () {
        return Math.atan2(this.x, this.y)
      }

      Victor.prototype.verticalAngleDeg = function () {
        return radian2degrees(this.verticalAngle())
      }

      Victor.prototype.angle = Victor.prototype.horizontalAngle
      Victor.prototype.angleDeg = Victor.prototype.horizontalAngleDeg
      Victor.prototype.direction = Victor.prototype.horizontalAngle

      Victor.prototype.rotate = function (angle) {
        const nx = (this.x * Math.cos(angle)) - (this.y * Math.sin(angle))
        const ny = (this.x * Math.sin(angle)) + (this.y * Math.cos(angle))

        this.x = nx
        this.y = ny

        return this
      }

      Victor.prototype.rotateDeg = function (angle) {
        angle = degrees2radian(angle)
        return this.rotate(angle)
      }

      Victor.prototype.rotateTo = function (rotation) {
        return this.rotate(rotation - this.angle())
      }

      Victor.prototype.rotateToDeg = function (rotation) {
        rotation = degrees2radian(rotation)
        return this.rotateTo(rotation)
      }

      Victor.prototype.rotateBy = function (rotation) {
        const angle = this.angle() + rotation

        return this.rotate(angle)
      }

      Victor.prototype.rotateByDeg = function (rotation) {
        rotation = degrees2radian(rotation)
        return this.rotateBy(rotation)
      }

      /**
 * Calculates the distance of the X axis between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceX(vec2);
 *     // => -100
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
      Victor.prototype.distanceX = function (vec) {
        return this.x - vec.x
      }

      /**
 * Same as `distanceX()` but always returns an absolute number
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.absDistanceX(vec2);
 *     // => 100
 *
 * @param {Victor} vector The second vector
 * @return {Number} Absolute distance
 * @api public
 */
      Victor.prototype.absDistanceX = function (vec) {
        return Math.abs(this.distanceX(vec))
      }

      /**
 * Calculates the distance of the Y axis between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceY(vec2);
 *     // => -10
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
      Victor.prototype.distanceY = function (vec) {
        return this.y - vec.y
      }

      /**
 * Same as `distanceY()` but always returns an absolute number
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceY(vec2);
 *     // => 10
 *
 * @param {Victor} vector The second vector
 * @return {Number} Absolute distance
 * @api public
 */
      Victor.prototype.absDistanceY = function (vec) {
        return Math.abs(this.distanceY(vec))
      }

      /**
 * Calculates the euclidean distance between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distance(vec2);
 *     // => 100.4987562112089
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
      Victor.prototype.distance = function (vec) {
        return Math.sqrt(this.distanceSq(vec))
      }

      /**
 * Calculates the squared euclidean distance between this vector and another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(200, 60);
 *
 *     vec1.distanceSq(vec2);
 *     // => 10100
 *
 * @param {Victor} vector The second vector
 * @return {Number} Distance
 * @api public
 */
      Victor.prototype.distanceSq = function (vec) {
        const dx = this.distanceX(vec)
        const dy = this.distanceY(vec)

        return dx * dx + dy * dy
      }

      /**
 * Calculates the length or magnitude of the vector
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.length();
 *     // => 111.80339887498948
 *
 * @return {Number} Length / Magnitude
 * @api public
 */
      Victor.prototype.length = function () {
        return Math.sqrt(this.lengthSq())
      }

      /**
 * Squared length / magnitude
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *
 *     vec.lengthSq();
 *     // => 12500
 *
 * @return {Number} Length / Magnitude
 * @api public
 */
      Victor.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y
      }

      Victor.prototype.magnitude = Victor.prototype.length

      /**
 * Returns a true if vector is (0, 0)
 *
 * ### Examples:
 *     var vec = new Victor(100, 50);
 *     vec.zero();
 *
 *     // => true
 *
 * @return {Boolean}
 * @api public
 */
      Victor.prototype.isZero = function () {
        return this.x === 0 && this.y === 0
      }

      /**
 * Returns a true if this vector is the same as another
 *
 * ### Examples:
 *     var vec1 = new Victor(100, 50);
 *     var vec2 = new Victor(100, 50);
 *     vec1.isEqualTo(vec2);
 *
 *     // => true
 *
 * @return {Boolean}
 * @api public
 */
      Victor.prototype.isEqualTo = function (vec2) {
        return this.x === vec2.x && this.y === vec2.y
      }

      /**
 * # Utility Methods
 */

      /**
 * Returns an string representation of the vector
 *
 * ### Examples:
 *     var vec = new Victor(10, 20);
 *
 *     vec.toString();
 *     // => x:10, y:20
 *
 * @return {String}
 * @api public
 */
      Victor.prototype.toString = function () {
        return 'x:' + this.x + ', y:' + this.y
      }

      /**
 * Returns an array representation of the vector
 *
 * ### Examples:
 *     var vec = new Victor(10, 20);
 *
 *     vec.toArray();
 *     // => [10, 20]
 *
 * @return {Array}
 * @api public
 */
      Victor.prototype.toArray = function () {
        return [this.x, this.y]
      }

      /**
 * Returns an object representation of the vector
 *
 * ### Examples:
 *     var vec = new Victor(10, 20);
 *
 *     vec.toObject();
 *     // => { x: 10, y: 20 }
 *
 * @return {Object}
 * @api public
 */
      Victor.prototype.toObject = function () {
        return { x: this.x, y: this.y }
      }

      const degrees = 180 / Math.PI

      function random (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min)
      }

      function radian2degrees (rad) {
        return rad * degrees
      }

      function degrees2radian (deg) {
        return deg / degrees
      }
    }, {}]
  }, {}, [1])(1)
})
